<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="RichTextBox1.Text" xml:space="preserve">
    <value>Ping is a computer network administration software utility used to test the reachability of a host on an Internet Protocol (IP) network. It measures the round-trip time for messages sent from the originating host to a destination computer that are echoed back to the source.

Ping operates by sending Internet Control Message Protocol (ICMP) echo request packets to the target host and waiting for an ICMP echo reply. The program reports errors, packet loss, and a statistical summary of the results, typically including the minimum, maximum, the mean round-trip times, and standard deviation of the mean.

Ping is NOT a port scanner and you cannot specify a port. The protocol itself (ICMP) is just from host to host


Example:
ping google.com -n 8   (pings google.com 8 times)

Usage: 
ping [-t] [-a] [-n count] [-l size] [-f] [-i TTL] [-v TOS] [-r count] [-s count] [[-j host-list] | [-k host-list]] [-w timeout] [-R] [-S srcaddr] [-c compartment] [-p] [-4] [-6] target_name

Options:
    -t             Ping the specified host until stopped.
                   To see statistics and continue - type Control-Break;
                   To stop - type Control-C.
    -a             Resolve addresses to hostnames.
    -n count       Number of echo requests to send.
    -l size        Send buffer size.
    -f             Set Don't Fragment flag in packet (IPv4-only).
    -i TTL         Time To Live.
    -v TOS         Type Of Service (IPv4-only. This setting has been deprecated
                   and has no effect on the type of service field in the IP
                   Header).
    -r count       Record route for count hops (IPv4-only).
    -s count       Timestamp for count hops (IPv4-only).
    -j host-list   Loose source route along host-list (IPv4-only).
    -k host-list   Strict source route along host-list (IPv4-only).
    -w timeout     Timeout in milliseconds to wait for each reply.
    -R             Use routing header to test reverse route also (IPv6-only).
                   Per RFC 5095 the use of this routing header has been
                   deprecated. Some systems may drop echo requests if
                   this header is used.
    -S srcaddr     Source address to use.
    -c compartment Routing compartment identifier.
    -p             Ping a Hyper-V Network Virtualization provider address.
    -4             Force using IPv4
    -6             Force using IPv6



</value>
  </data>
  <data name="RichTextBox2.Text" xml:space="preserve">
    <value>traceroute is a computer network diagnostic tool for displaying the route (path) and measuring transit delays of packets across an Internet Protocol (IP) network. The history of the route is recorded as the round-trip times of the packets received from each successive host (remote node) in the route (path); the sum of the mean times in each hop is a measure of the total time spent to establish the connection.

Traceroute proceeds unless all (three) sent packets are lost more than twice, then the connection is lost and the route cannot be evaluated. Ping, on the other hand, only computes the final round-trip times from the destination point.


It is primarily used to only find the ROUTE of the traffic from the client to the host.

It is NOT an accurate tool for latency testing.


Example: 
tracert google.com

Usage:
tracert [-d] [-h maximum_hops] [-j host-list] [-w timeout] [-R] [-S srcaddr] [-4] [-6] target_name

Options:
    -d                 Do not resolve addresses to hostnames.
    -h maximum_hops    Maximum number of hops to search for target.
    -j host-list       Loose source route along host-list (IPv4-only).
    -w timeout         Wait timeout milliseconds for each reply.
    -R                 Trace round-trip path (IPv6-only).
    -S srcaddr         Source address to use (IPv6-only).
    -4                 Force using IPv4.
    -6                 Force using IPv6.</value>
  </data>
  <data name="RichTextBox3.Text" xml:space="preserve">
    <value>PathPing is a network utility supplied in Windows NT and beyond that combines the functionality of ping with that of tracert.

It provides details of the path between two hosts and Ping-like statistics for each node in the path based on samples taken over a time period, depending on how many nodes are between the start and end host.

The advantages of PathPing over ping and traceroute are that each node is pinged as the result of a single command, and that the behavior of nodes is studied over an extended time period, rather than the default ping sample of four messages or default traceroute single route trace. 

The disadvantage is that it takes a total of 25 seconds per hop to show the ping statistics.



It is very similar to TraceRoute but is more in depth and accurate.

PathPing is used for finding LATENCY of each node between you and the host. It will ping each host a number of times to determine packet latency and packet loss.


Example:
pathping google.com

Usage:
pathping [-g host-list] [-h maximum_hops] [-i address] [-n] [-p period] [-q num_queries] [-w timeout] [-4] [-6] target_name

Options:
    -g host-list     Loose source route along host-list.
    -h maximum_hops  Maximum number of hops to search for target.
    -i address       Use the specified source address.
    -n               Do not resolve addresses to hostnames.
    -p period        Wait period milliseconds between pings.
    -q num_queries   Number of queries per hop.
    -w timeout       Wait timeout milliseconds for each reply.
    -4               Force using IPv4.
    -6               Force using IPv6.



</value>
  </data>
  <data name="RichTextBox4.Text" xml:space="preserve">
    <value>NSlookup is an interactive tool for checking DNS resolution.

By default it will use the DNS server set in your network adapter either manually or by your modem/router. However, you can set a custom DNS server to use.


Example:
nslookup google.com 8.8.8.8

Usage:
nslookup (interactive mode, will use default DNS server)

nslookup - [DNS server to query] (interactive mode using custom DNS server)

nslookup [domain] (will use default DNS server)

nslookup [domain] [DNS server to query]</value>
  </data>
  <data name="RichTextBox5.Text" xml:space="preserve">
    <value>If you are experiencing problems with network communications, then network statistics can sometimes help point you toward the root cause of the problem. That’s where the aptly named NetStat command comes into play. This command has a number of different functions, but the most useful of these is to display network summary information for the device. To see this type of summary information, just type NetStat -e

Usage:
NETSTAT [-a] [-b] [-e] [-f] [-n] [-o] [-p proto] [-r] [-s] [-x] [-t] [interval]

  -a            Displays all connections and listening ports.

  -b            Displays the executable involved in creating each connection or listening port. In some cases well-known executables host multiple independent components, and in these cases the sequence of components involved in creating the connection or listening port is displayed. In this case the executable name is in [] at the bottom, on top is the component it called, and so forth until TCP/IP was reached. Note that this option can be time-consuming and will fail unless you have sufficient permissions.

  -e            Displays Ethernet statistics. This may be combined with the -s
                option.

  -f            Displays Fully Qualified Domain Names (FQDN) for foreign
                addresses.

  -n            Displays addresses and port numbers in numerical form.

  -o            Displays the owning process ID associated with each connection.

  -p proto      Shows connections for the protocol specified by proto; proto may be any of: TCP, UDP, TCPv6, or UDPv6.  If used with the -s option to display per-protocol statistics, proto may be any of: IP, IPv6, ICMP, ICMPv6, TCP, TCPv6, UDP, or UDPv6.

  -q            Displays all connections, listening ports, and bound nonlistening TCP ports. Bound nonlistening ports may or may not be associated with an active connection.

  -r            Displays the routing table.

  -s            Displays per-protocol statistics.  By default, statistics are shown for IP, IPv6, ICMP, ICMPv6, TCP, TCPv6, UDP, and UDPv6; the -p option may be used to specify a subset of the default.

  -t            Displays the current connection offload state.

  -x            Displays NetworkDirect connections, listeners, and shared
                endpoints.

  -y            Displays the TCP connection template for all connections. Cannot be combined with the other options.

  interval      Redisplays selected statistics, pausing interval seconds between each display.  Press CTRL+C to stop redisplaying statistics.  If omitted, netstat will print the current configuration information once.</value>
  </data>
  <data name="RichTextBox6.Text" xml:space="preserve">
    <value>The ARP command corresponds to the Address Resolution Protocol. Although it is easy to think of network communications in terms of IP addressing, packet delivery is ultimately dependent on the Media Access Control (MAC) address of the device’s network adapter. This is where the Address Resolution Protocol comes into play. Its job is to map IP addresses to MAC addresses.

Windows devices maintain an ARP cache, which contains the results of recent ARP queries. You can see the contents of this cache by using the ARP -A command. If you are having problems communicating with one specific host, you can append the remote host’s IP address to the ARP -A command.

When ran, it will show all IP addresses ARP-ed from the computer you rubn it on.

Usage:
arp -a		Displays the ARP table.
arp -s [IP] [MAC]	Adds a static entry</value>
  </data>
  <data name="RichTextBox7.Text" xml:space="preserve">
    <value>Displays protocol statistics and current TCP/IP connections using NBT
(NetBIOS over TCP/IP).

NBTSTAT [ [-a RemoteName] [-A IP address] [-c] [-n]
        [-r] [-R] [-RR] [-s] [-S] [interval] ]

  -a   (adapter status) Lists the remote machine's name table given its name

  -A   (Adapter status) Lists the remote machine's name table given its IP address.

  -c   (cache)          Lists NBT's cache of remote [machine] names and their IP addresses

  -n   (names)          Lists local NetBIOS names.

  -r   (resolved)       Lists names resolved by broadcast and via WINS

  -R   (Reload)         Purges and reloads the remote cache name table

  -S   (Sessions)       Lists sessions table with the destination IP addresses

  -s   (sessions)       Lists sessions table converting destination IP addresses to computer NETBIOS names.

  -RR  (ReleaseRefresh) Sends Name Release packets to WINS and then, starts Refresh

  RemoteName   Remote host machine name.
  IP address   Dotted decimal representation of the IP address.
  interval     Redisplays selected statistics, pausing interval seconds
               between each display. Press Ctrl+C to stop redisplaying
               statistics.</value>
  </data>
  <data name="RichTextBox9.Text" xml:space="preserve">
    <value>IPconfig allows you to view the IP address of the host, release the IP address, request a new one, and flush the DNS cache.

If you have connection issues with your machine, run these commands one after another:
ipconfig /release
ipconfig /renew
ipconfig /flushdns


Usage:
ipconfig /&lt;task&gt;

/all	Display full configuration information

/release         Release the IPv4 address for the specified adapter.

/release6        Release the IPv6 address for the specified adapter.

/renew           Renew the IPv4 address for the specified adapter.

/renew6          Renew the IPv6 address for the specified adapter.

/flushdns        Purges the DNS Resolver cache.

/registerdns     Refreshes all DHCP leases and re-registers DNS names

/displaydns      Display the contents of the DNS Resolver Cache.

/showclassid     Displays all the dhcp class IDs allowed for adapter.

/setclassid      Modifies the dhcp class id.

/showclassid6    Displays all the IPv6 DHCP class IDs allowed for adapter.

/setclassid6     Modifies the IPv6 DHCP class id.</value>
  </data>
  <data name="RichTextBox10.Text" xml:space="preserve">
    <value>Iperf is available at: 
https://iperf.fr/iperf-download.php

Iperf is a tool to test the bandwidth between hosts.

To use Iperf a number of conditions must be met:
-Iperf must be running on BOTH machines you are testing between
-Both machines must be able to connect to each other
-You must have the "cygwin1.dll" file in the same folder as iperf3.exe

Using Iperf in Windows:
-Navigate to the location of the iperf3.exe folder
-Right click on the window to open a Command Prompt in that location
-If you cannot open command prompt there, open Command Prompt from the Start Menu
-Right click in the window that iperf3.exe is located, and click Properties. Note the Location
-In Command Prompt, run the command "cd &lt;location from previous step&gt;"
-Check the file is in there by running the "dir" command
-Once you're sure it's in there, run it in either client or server mode
-To run in server mode (receiving data):  iperf3.exe -s
-To run as the client (sending data):        iperf3.exe -c &lt;host IP&gt;

Using Iperf in Linux:
-Open a Terminal window
-To run in server mode (receiving data):  iperf3 -s
-To run as the client (sending data):        iperf3 -c &lt;host IP&gt;

Usage: iperf [-s|-c host] [options]
       iperf [-h|--help] [-v|--version]

Server or Client:
  -p, --port      #         server port to listen on/connect to (defaults to 5201)

  -f, --format    [kmgKMG]  format to report: Kbits, Mbits, KBytes, MBytes

  -i, --interval  #         seconds between periodic bandwidth reports


  -F, --file name           xmit/recv the specified file

  -B, --bind      &lt;host&gt;    bind to a specific interface

  -V, --verbose             more detailed output

  -J, --json                output in JSON format

  --logfile f               send output to a log file

  -d, --debug               emit debugging output

  -v, --version             show version information and quit

  -h, --help                show this message and quit


Server specific:
  -s, --server              run in server mode

  -D, --daemon              run the server as a daemon

  -I, --pidfile file        write PID file

  -1, --one-off             handle one client connection then exit


Client specific:
  -c, --client    &lt;host&gt;    run in client mode, connecting to &lt;host&gt;

  -u, --udp                 use UDP rather than TCP

  -b, --bandwidth #[KMG][/#] target bandwidth in bits/sec (0 for unlimited)
                            (default 1 Mbit/sec for UDP, unlimited for TCP)
                            (optional slash and packet count for burst mode)

  -t, --time      #         time in seconds to transmit for (default 10 secs)

  -n, --bytes     #[KMG]    number of bytes to transmit (instead of -t)

  -k, --blockcount #[KMG]   number of blocks (packets) to transmit (instead of -t or -n)

  -l, --len       #[KMG]    length of buffer to read or write
                            (default 128 KB for TCP, 8 KB for UDP)

  --cport         &lt;port&gt;    bind to a specific client port (TCP and UDP, default: ephemeral port)

  -P, --parallel  #         number of parallel client streams to run

  -R, --reverse             run in reverse mode (server sends, client receives)

  -w, --window    #[KMG]    set window size / socket buffer size

  -M, --set-mss   #         set TCP/SCTP maximum segment size (MTU - 40 bytes)

  -N, --no-delay            set TCP/SCTP no delay, disabling Nagle's Algorithm

  -4, --version4            only use IPv4

  -6, --version6            only use IPv6

  -S, --tos N               set the IP 'type of service'

  -Z, --zerocopy            use a 'zero copy' method of sending data

  -O, --omit N              omit the first n seconds

  -T, --title str           prefix every output line with this string

  --get-server-output       get results from server

  --udp-counters-64bit      use 64-bit counters in UDP test packets

[KMG] indicates options that support a K/M/G suffix for kilo-, mega-, or giga-

iperf3 homepage at: http://software.es.net/iperf/
Report bugs to:     https://github.com/esnet/iperf</value>
  </data>
</root>